{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./sources/ext/auto_scheduling/task_plan.ts","webpack:///./sources/core/relations/links_builder.js","webpack:///./sources/utils/helpers.js","webpack:///./sources/ext/auto_scheduling/constraint_types.ts","webpack:///./sources/ext/auto_scheduling/ui_handlers.ts","webpack:///./sources/ext/auto_scheduling/loops_finder.ts","webpack:///./sources/core/relations/graph_helper.js","webpack:///./sources/ext/auto_scheduling/connected_groups.ts","webpack:///./sources/ext/auto_scheduling/asap_strategy.ts","webpack:///./sources/ext/auto_scheduling/alap_strategy.ts","webpack:///./sources/ext/auto_scheduling/planner.ts","webpack:///./sources/ext/auto_scheduling/constraints.ts","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/core/relations/links_common.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TaskPlan","this","link","task","start_date","end_date","latestStart","earliestStart","earliestEnd","latestEnd","latestSchedulingStart","earliestSchedulingStart","latestSchedulingEnd","earliestSchedulingEnd","kind","conflict","Create","parent","plan","undefined","gantt","getVirtualRoot","mixin","getSubtaskDates","id","config","root_id","type","types","project","$source","$target","$virtual","getLinkedTasks","includePredecessors","startIds","clearCache","_isLinksCacheEnabled","_startLinksCache","relations","visited","result","length","_getLinkedTasks","push","_endLinksCache","_collectRelations","rootObj","isChild","visitedLinks","linkKey","successors","_getSuccessors","predecessors","_getPredecessors","hashSum","rootTask","visitedTasks","output","from","tasksStack","current","pop","isTaskExists","getTask","rel","isSameParent","sourceParent","targetParent","target","hasChild","children","getChildren","units","second","minute","hour","day","week","month","quarter","year","arrayFilter","arr","callback","filter","getSecondsInUnit","unit","forEach","workArray","slice","arrayMap","map","resArray","arrayFind","find","arrayDifference","item","arraySome","hashToArray","hash","sortArrayOfHash","field","desc","compare","b","sort","throttle","timeout","wait","apply","arguments","setTimeout","isArray","obj","Array","isDate","getFullYear","getMonth","getDate","isStringObject","Function","toString","constructor","isNumberObject","isBooleanObject","delay","timer","$cancelTimeout","$pending","args","clearTimeout","$execute","objectKeys","keys","requestAnimationFrame","w","webkitRequestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","cb","isEventable","attachEvent","detachEvent","ConstraintTypes","attachUIHandlers","linksBuilder","loopsFinder","connectedGroupsHelper","_attachAutoSchedulingHandlers","_autoScheduleAfterLinkChange","auto_scheduling","_autoscheduling_in_progress","autoSchedule","source","_preventCircularLink","isCircularLink","callEvent","getLoopContainingLink","_preventDescendantLink","auto_scheduling_descendant_links","isChildOf","isSummaryTask","_datesNotEqual","dateA","dateB","taskA","taskB","valueOf","_hasDuration","_notEqualTaskDates","task1","task2","getConstraintType","constraint_date","duration","milestone","getRelations","auto_scheduling_compatibility","getConnectedGroupRelations","movedTask","updateTaskConstraints","schedule_from_end","constraint_type","constraint_types","FNLT","Date","SNET","finalizeTaskConstraints","auto_scheduling_strict","auto_scheduling_initial","auto_scheduling_move_projects","changedConstraint","_autoScheduleAfterDND","taskId","newTask","calculateDuration","relationsArray","skipped","originalLink","getLink","links","start_to_start","start_to_finish","splice","presentLinks","updatedLinks","resetToStartLinksLags","_autoSchedule","modifiedTaskId","ext","inlineEditors","autoscheduleColumns_1","state","columnName","editorConfig","getEditorConfig","map_to","oldTask","LoopsFinder","graphHelper","_this","_graphHelper","_linksBuilder","_gantt","allRelations","isLinkExists","concat","_formatLink","cycles","findLoops","j","findCycles","helpers","getVertices","ids","len","vertices","topologicalSort","edges","$incoming","successor","S","v","L","node","groupAdjacentEdges","edge","res","tarjanStronglyConnectedComponents","verticesHash","stack","edgesFromTasks","recurse","connectedComponents","getVertex","workStack","index","lowLink","onStack","e","Math","min","com","tasks","component","breadthFirstSearch","currentVertex","queue","groupTasks","groupLinksInternal","groupLinksPublic","shift","linksArray","linksObjects","processedLinks","ConnectedGroupsHelper","getConnectedGroup","group","groups","length_1","findGroups","task_plan_1","AsapStrategy","instance","resolveRelationDate","adjacentLinks","plansHash","minStart","linkId","defaultStart","minRelationDate","relation","preferredStart","constraintDate","getEarliestStartDate","isSmallerOrDefault","project_start","maxEnd","getClosestWorkTime","date","dir","calculateEndDate","masterPlan","currentPlan","isEqual","isFirstSmaller","small","big","smallDate","bigDate","getPredecessorEndDate","predecessorEnd","successorStart","lag","AlapStrategy","maxStart","maxRelationDate","getLatestEndDate","constraintStartDate","isGreaterOrDefault","project_end","getSuccessorStartDate","predecessor","alap_strategy_1","asap_strategy_1","constraint_types_1","AutoSchedulingPlanner","constraintsHelper","_constraintsHelper","_asapStrategy","_alapStrategy","generatePlan","constraints","alapStrategy","asapStrategy","_a","buildWorkCollections","orderedIds","reversedIds","relationsMap","processConstraints","iterateTasks","isAlapTask","isAsapTask","applyProjectPlan","projectPlan","reason","updateTasks","newDate","mainSequence","secondarySequence","isMainSequence","mainSequenceStrategy","secondarySequenceStrategy","currentId","limitPlanDates","processResolvedDate","effectiveStart","reverse","unshift","constraintType","ASAP","ALAP","processConstraint","ConstraintsHelper","hasConstraint","newPlan","SNLT","FNET","MSO","MFO","getConstraints","store","eachTask","planner","connectedGroups","getConstraintLimitations","updatedTasks","startTask","preferInitialTaskDates","batchUpdate","payload","updateTask","eachParent","resetTime","start","end","resetProjectDates","updateParentsAndCallEvents","inclusive","auto_scheduling_compatible","parseDate","_get_linked_task","getTarget","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_getImplicitLinks","respectTargetOffset","targetDates","to","getState","drag_id","fromLength","fromTask","toLength","toTask","subtaskLink","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","selectOffset","selectSourceLinks","skipChild","linksCollection","siblingLink","siblingId","siblingTask","abs","_getDirectDependencies","selectSuccessors","linksIds","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","skipInherited","sourceTask","targetTask","finish_to_start","additionalLag","finish_to_finish"],"mappings":"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","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 255);\n","export class TaskPlan implements ITaskPlan {\n\tstatic Create(parent?: TaskPlan): TaskPlan {\n\t\tconst plan = new TaskPlan();\n\t\tif (parent) {\n\t\t\tfor (const i in plan) {\n\t\t\t\tif (parent[i] !== undefined) {\n\t\t\t\t\tplan[i] = parent[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tpublic link: string | number;\n\tpublic task: string | number;\n\t// tslint:disable-next-line variable-name\n\tpublic start_date: Date | null;\n\t// tslint:disable-next-line variable-name\n\tpublic end_date: Date | null;\n\n\tpublic latestStart: Date;\n\tpublic earliestStart: Date;\n\tpublic earliestEnd: Date;\n\tpublic latestEnd: Date;\n\n\tpublic latestSchedulingStart: Date;\n\tpublic earliestSchedulingStart: Date;\n\tpublic latestSchedulingEnd: Date;\n\tpublic earliestSchedulingEnd: Date;\n\n\tpublic kind: string;\n\tpublic conflict: boolean;\n\n\tconstructor() {\n\t\tthis.link = null;\n\t\tthis.task = null;\n\t\tthis.start_date = null;\n\t\tthis.end_date = null;\n\t\tthis.latestStart = null;\n\t\tthis.earliestStart = null;\n\t\tthis.earliestEnd = null;\n\t\tthis.latestEnd = null;\n\t\tthis.latestSchedulingStart = null;\n\t\tthis.earliestSchedulingStart = null;\n\t\tthis.latestSchedulingEnd = null;\n\t\tthis.earliestSchedulingEnd = null;\n\t\tthis.kind = \"asap\";\n\t\tthis.conflict = false;\n\t}\n}","module.exports = function(gantt) {\n\treturn {\n\t\tgetVirtualRoot: function(){\n\t\t\treturn gantt.mixin(\n\t\t\t\tgantt.getSubtaskDates(),\n\t\t\t\t{\n\t\t\t\t\tid: gantt.config.root_id,\n\t\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t\t$source: [],\n\t\t\t\t\t$target: [],\n\t\t\t\t\t$virtual: true\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\n\t\tgetLinkedTasks: function(id, includePredecessors){\n\t\t\tvar startIds = [id];\n\t\n\t\t\t//TODO: format links cache\n\t\t\tvar clearCache = false;\n\t\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\t\tgantt._startLinksCache();\n\t\t\t\tclearCache = true;\n\t\t\t}\n\t\t\tvar relations = [];\n\t\t\tvar visited = {};\n\t\t\tvar result = {};\n\t\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors, result);\n\t\t\t}\n\t\n\t\t\tfor(var i in result){\n\t\t\t\trelations.push(result[i]);\n\t\t\t}\n\t\n\t\t\t//TODO: remove redundant edges before continue https://en.wikipedia.org/wiki/Transitive_reduction\n\t\t\tif(clearCache)\n\t\t\t\tgantt._endLinksCache();\n\t\t\treturn relations;\n\t\t},\n\t\n\t\t_collectRelations: function(rootObj, isChild, includePredecessors, visitedLinks){\n\t\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\t\n\t\t\tvar predecessors = [];\n\t\t\tif (includePredecessors) {\n\t\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t\t}\n\t\t\t\n\t\t\tvar linkKey;\n\t\t\tvar relations = [];\n\t\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\t\tlinkKey = successors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(successors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\t\tlinkKey = predecessors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(predecessors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn relations;\n\t\t},\n\t\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, output) {\n\t\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\t\tvar visitedTasks = {};\n\t\t\tvar visitedLinks = {};\n\t\t\tvar rootObj;\n\t\n\t\t\tvar tasksStack = [{from: from, includePredecessors: includePredecessors, isChild:false}];\n\t\n\t\t\twhile(tasksStack.length){\n\t\t\t\tvar current = tasksStack.pop();\n\t\t\t\tvar isChild = current.isChild;\n\t\n\t\t\t\tfrom = current.from;\n\t\t\t\tif(visitedTasks[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\t\t\tvisitedTasks[from] = true;\n\t\t\t\t\n\t\t\t\tvar relations = this._collectRelations(rootObj, isChild, includePredecessors, visitedLinks);\n\t\n\t\t\t\tfor(var i=0; i < relations.length; i++){\n\t\t\t\t\tvar rel = relations[i];\n\t\t\t\t\toutput[rel.hashSum] = rel;\n\t\t\t\t\tvar isSameParent = rel.sourceParent == rel.targetParent;\n\t\t\t\t\tvar targetTask = rel.target;\n\t\t\t\t\tif(!visitedTasks[targetTask])\n\t\t\t\t\t\ttasksStack.push({from: rel.target, includePredecessors: true, isChild: isSameParent});\n\t\t\t\t}\n\t\n\t\t\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\t\t\tif(!visitedTasks[children[i]])\n\t\t\t\t\t\t\ttasksStack.push({from: children[i], includePredecessors: true, isChild: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t}\n\t};\n};","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback) {\n\tif (arr.forEach) {\n\t\tarr.forEach(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback) {\n\tif (arr.map) {\n\t\treturn arr.map(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\t\treturn resArray;\n\t}\n}\n\n\nfunction arrayFind(arr, callback) {\n\tif (arr.find) {\n\t\treturn arr.find(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// iframe-safe array type check instead of using instanceof\nfunction isArray(obj){\n\tif(Array.isArray){\n\t\treturn Array.isArray(obj);\n\t}else{\n\t\t// close enough\n\t\treturn (obj && obj.length !== undefined && obj.pop && obj.push);\n\t}\n}\n\n// non-primitive string object, e.g. new String(\"abc\")\nfunction isStringObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function String() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Number(5)\nfunction isNumberObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Number() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Boolean(true)\nfunction isBooleanObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Boolean() { [native code] }\";\n}\n\nfunction isDate(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\treturn !!(obj.getFullYear && obj.getMonth && obj.getDate);\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction arrayFilter(arr, callback) {\n\tvar result = [];\n\n\tif (arr.filter) {\n\t\treturn arr.filter(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\tresult[result.length] = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction hashToArray(hash) {\n\tvar result = [];\n\n\tfor (var key in hash) {\n\t\tif (hash.hasOwnProperty(key)) {\n\t\t\tresult.push(hash[key]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction arraySome(arr, callback) {\n\tif (arr.length === 0) return false;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (callback(arr[i], i, arr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction arrayDifference(arr, callback) {\n\treturn arrayFilter(arr, function(item, i) {\n\t\treturn !callback(item, i);\n\t});\n}\n\nfunction throttle (callback, timeout) {\n\tvar wait = false;\n\n\treturn function () {\n\t\tif (!wait) {\n\t\t\tcallback.apply(null, arguments);\n\t\t\twait = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\twait = false;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\nfunction delay (callback, timeout){\n\tvar timer;\n\n\tvar result = function() {\n\t\tresult.$cancelTimeout();\n\t\tcallback.$pending = true;\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\ttimer = setTimeout(function(){\n\t\t\tcallback.apply(this, args);\n\t\t\tresult.$pending = false;\n\t\t}, timeout);\n\t};\n\t\n\tresult.$pending = false;\n\tresult.$cancelTimeout = function(){\n\t\tclearTimeout(timer);\n\t\tcallback.$pending = false;\n\t};\n\tresult.$execute = function(){\n\t\tcallback();\n\t\tcallback.$cancelTimeout();\n\t};\n\n\treturn result;\n}\n\nfunction sortArrayOfHash(arr, field, desc) {\n\tvar compare = function(a, b) {\n\t\treturn a < b;\n\t};\n\n\tarr.sort(function(a, b) {\n\t\tif (a[field] === b[field]) return 0;\n\n\t\treturn desc ? compare(a[field], b[field]) : compare(b[field], a[field]);\n\t});\n}\n\nfunction objectKeys(obj) {\n\tif (Object.keys) {\n\t\treturn Object.keys(obj);\n\t}\n\tvar result = [];\n\tvar key;\n\tfor (key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction requestAnimationFrame(callback) {\n\tvar w = window;\n\tvar foundRequestAnimationFrame = w.requestAnimationFrame\n\t\t|| w.webkitRequestAnimationFrame\n\t\t|| w.msRequestAnimationFrame\n\t\t|| w.mozRequestAnimationFrame\n\t\t|| w.oRequestAnimationFrame\n\t\t|| function(cb) { setTimeout(cb, 1000/60); };\n\treturn foundRequestAnimationFrame(callback);\n}\n\nfunction isEventable(obj) {\n\treturn obj.attachEvent && obj.detachEvent;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap,\n\tarrayFind: arrayFind,\n\tarrayFilter: arrayFilter,\n\tarrayDifference: arrayDifference,\n\tarraySome: arraySome,\n\thashToArray: hashToArray,\n\tsortArrayOfHash: sortArrayOfHash,\n\tthrottle: throttle,\n\tisArray: isArray,\n\tisDate: isDate,\n\tisStringObject: isStringObject,\n\tisNumberObject: isNumberObject,\n\tisBooleanObject: isBooleanObject,\n\tdelay: delay,\n\tobjectKeys: objectKeys,\n\trequestAnimationFrame: requestAnimationFrame,\n\tisEventable: isEventable\n};","export enum ConstraintTypes {\n\t// As Soon As Possible (ASAP)\n\tASAP = \"asap\",\n\t// As Late As Possible (ALAP)\n\tALAP = \"alap\",\n\t// Start No Earlier Than (SNET)\n\tSNET = \"snet\",\n\t// Start No Later Than (SNLT)\n\tSNLT = \"snlt\",\n\t// Finish No Earlier Than (FNET)\n\tFNET = \"fnet\",\n\t// Finish No Later Than (FNLT)\n\tFNLT = \"fnlt\",\n\t// Must Start On (MSO)\n\tMSO = \"mso\",\n\t// Must Finish On (MFO)\n\tMFO = \"mfo\"\n}","import { ConnectedGroupsHelper } from \"./connected_groups\";\n\nexport function attachUIHandlers(\n\tgantt: any,\n\tlinksBuilder: any,\n\tloopsFinder: any,\n\tconnectedGroupsHelper: ConnectedGroupsHelper\n) {\n\tlet _attachAutoSchedulingHandlers = function() {\n\t\tfunction _autoScheduleAfterLinkChange(id: LinkID, link: ILink) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tgantt.autoSchedule(link.source);\n\t\t\t}\n\t\t}\n\n\t\tgantt.attachEvent(\"onAfterLinkUpdate\", _autoScheduleAfterLinkChange);\n\t\tgantt.attachEvent(\"onAfterLinkAdd\", _autoScheduleAfterLinkChange);\n\n\t\tgantt.attachEvent(\"onAfterLinkDelete\", function(id: LinkID, link: ILink) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\t!gantt._autoscheduling_in_progress &&\n\t\t\t\tgantt.isTaskExists(link.target)\n\t\t\t) {\n\t\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\t\tconst target = gantt.getTask(link.target);\n\t\t\t\tconst predecessors = gantt._getPredecessors(target);\n\t\t\t\tif (predecessors.length) {\n\t\t\t\t\tgantt.autoSchedule(predecessors[0].source, false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tgantt.attachEvent(\"onParse\", function() {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_initial\n\t\t\t) {\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t});\n\n\t\tfunction _preventCircularLink(id: LinkID, link: ILink): boolean {\n\t\t\tif (gantt.isCircularLink(link)) {\n\t\t\t\tgantt.callEvent(\"onCircularLinkError\", [\n\t\t\t\t\tlink,\n\t\t\t\t\tloopsFinder.getLoopContainingLink(link)\n\t\t\t\t]);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _preventDescendantLink(id: LinkID, link: ILink): boolean {\n\t\t\tconst source = gantt.getTask(link.source);\n\t\t\tconst target = gantt.getTask(link.target);\n\n\t\t\tif (!gantt.config.auto_scheduling_descendant_links) {\n\t\t\t\tif (\n\t\t\t\t\t(gantt.isChildOf(source.id, target.id) &&\n\t\t\t\t\t\tgantt.isSummaryTask(target)) ||\n\t\t\t\t\t(gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventDescendantLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventDescendantLink);\n\n\t\tfunction _datesNotEqual(\n\t\t\tdateA: Date,\n\t\t\tdateB: Date,\n\t\t\ttaskA: ITask,\n\t\t\ttaskB: ITask\n\t\t): boolean {\n\t\t\tif (!!dateA !== !!dateB) {\n\t\t\t\t// if one of dates is empty or null and the other is not\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!dateA && !dateB) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (dateA.valueOf() > dateB.valueOf()) {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateB,\n\t\t\t\t\tend_date: dateA,\n\t\t\t\t\ttask: taskB\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateA,\n\t\t\t\t\tend_date: dateB,\n\t\t\t\t\ttask: taskA\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfunction _notEqualTaskDates(task1: ITask, task2: ITask): boolean {\n\t\t\tif (_datesNotEqual(task1.start_date, task2.start_date, task1, task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (gantt.getConstraintType(task1) !== gantt.getConstraintType(task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(\n\t\t\t\t\ttask1.constraint_date,\n\t\t\t\t\ttask2.constraint_date,\n\t\t\t\t\ttask1,\n\t\t\t\t\ttask2\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t\t((_datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\t\ttask1.duration !== task2.duration) &&\n\t\t\t\t\ttask1.type !== gantt.config.types.milestone)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getRelations(id: TaskID) {\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility) {\n\t\t\t\t// collect only downstream dependencies since there is no backward or ALAP scheduling in pre 6.1 auto scheduling\n\t\t\t\treturn linksBuilder.getLinkedTasks(id, true);\n\t\t\t} else {\n\t\t\t\t// get all connected group (both upstream and downstream dependencies)\n\t\t\t\treturn connectedGroupsHelper.getConnectedGroupRelations(id);\n\t\t\t}\n\t\t}\n\n\t\tlet relations;\n\t\tlet movedTask;\n\t\tgantt.attachEvent(\"onBeforeTaskDrag\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_move_projects\n\t\t\t) {\n\t\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\t\trelations = getRelations(id);\n\n\t\t\t\tmovedTask = id;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tfunction resetToStartLinksLags(taskId, relationsArray) {\n\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish_to_start links\n\t\t\t// recalculate these links if task duration has changed\n\n\t\t\tlet skipped = false;\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst originalLink = gantt.getLink(relationsArray[i].id);\n\t\t\t\tif (\n\t\t\t\t\toriginalLink &&\n\t\t\t\t\t(originalLink.type === gantt.config.links.start_to_start ||\n\t\t\t\t\t\toriginalLink.type === gantt.config.links.start_to_finish)\n\t\t\t\t) {\n\t\t\t\t\trelationsArray.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tskipped = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skipped) {\n\t\t\t\tconst presentLinks = {};\n\t\t\t\tfor (let i = 0; i < relationsArray.length; i++) {\n\t\t\t\t\tpresentLinks[relationsArray[i].id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst updatedLinks = getRelations(taskId);\n\n\t\t\t\tfor (let i = 0; i < updatedLinks.length; i++) {\n\t\t\t\t\tif (!presentLinks[updatedLinks[i].id]) {\n\t\t\t\t\t\trelationsArray.push(updatedLinks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateTaskConstraints(task){\n\t\t\tif (gantt.config.schedule_from_end) {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.FNLT;\n\t\t\t\ttask.constraint_date = new Date(task.end_date);\n\t\t\t} else {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.SNET;\n\t\t\t\ttask.constraint_date = new Date(task.start_date);\n\t\t\t}\n\t\t}\n\n\t\tfunction finalizeTaskConstraints(task){\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility && gantt.config.auto_scheduling_strict) {\n\t\t\t\tif (task.constraint_type === gantt.config.constraint_types.SNET ||\n\t\t\t\t\ttask.constraint_type === gantt.config.constraint_types.FNLT) {\n\t\t\t\t\t\ttask.constraint_type = null;\n\t\t\t\t\t\ttask.constraint_date = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst _autoScheduleAfterDND = function(taskId, task) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst newTask = gantt.getTask(taskId);\n\n\t\t\t\tif (_notEqualTaskDates(task, newTask)) {\n\t\t\t\t\tupdateTaskConstraints(newTask);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tgantt.config.auto_scheduling_move_projects &&\n\t\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\t\tmovedTask == taskId\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgantt.calculateDuration(task) !== gantt.calculateDuration(newTask)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgantt._autoSchedule(taskId, relations);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalizeTaskConstraints(newTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\trelations = null;\n\t\t\tmovedTask = null;\n\t\t\treturn true;\n\t\t};\n\n\n\n\n\t\tlet modifiedTaskId = null;\n\t\tif (gantt.ext && gantt.ext.inlineEditors) {\n\t\t\tconst inlineEditors = gantt.ext.inlineEditors;\n\t\t\tconst autoscheduleColumns = {\n\t\t\t\tstart_date: true,\n\t\t\t\tend_date: true,\n\t\t\t\tduration: true,\n\t\t\t\tconstraint_type: true,\n\t\t\t\tconstraint_date: true\n\t\t\t};\n\n\t\t\tinlineEditors.attachEvent(\"onBeforeSave\", function(state) {\n\t\t\t\tif (autoscheduleColumns[state.columnName]) {\n\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tlet changedConstraint;\n\t\tfunction onBeforeLigthboxSaveHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tchangedConstraint = false;\n\t\t\t\tconst oldTask = gantt.getTask(taskId);\n\t\t\t\tif (_notEqualTaskDates(task, oldTask)) {\n\t\t\t\t\tmodifiedTaskId = taskId;\n\t\t\t\t\tif(gantt.getConstraintType(task) !== gantt.getConstraintType(oldTask) ||\n\t\t\t\t\t\t+task.constraint_date !== +oldTask.constraint_date\n\t\t\t\t\t){\n\t\t\t\t\t\tchangedConstraint = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction onAfterTaskUpdateHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif (\n\t\t\t\t\tmodifiedTaskId &&\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\tmodifiedTaskId == taskId\n\t\t\t\t) {\n\t\t\t\t\tmodifiedTaskId = null;\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tupdateTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t\tgantt.autoSchedule(task.id);\n\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tfinalizeTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeTaskChanged\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\treturn _autoScheduleAfterDND(id, task);\n\t\t});\n\n\t\tif(gantt.ext.inlineEditors){\n\t\t\tgantt.ext.inlineEditors.attachEvent(\"onBeforeSave\", function(state){\n\t\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\t\tconst api = gantt.ext.inlineEditors;\n\t\t\t\t\tconst editorConfig = api.getEditorConfig(state.columnName);\n\t\t\t\t\tif(editorConfig.map_to === \"start_date\" || editorConfig.map_to === \"end_date\" || editorConfig.map_to === \"duration\"){\n\t\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tgantt.attachEvent(\"onLightboxSave\", onBeforeLigthboxSaveHandler);\n\t\tgantt.attachEvent(\"onAfterTaskUpdate\", onAfterTaskUpdateHandler);\n\t};\n\n\tgantt.attachEvent(\"onGanttReady\", function() {\n\t\t_attachAutoSchedulingHandlers();\n\t\t// attach handlers only when initialized for the first time\n\t\t_attachAutoSchedulingHandlers = function() { };\n\t});\n}\n","export class LoopsFinder {\n\tprivate _linksBuilder: any;\n\tprivate _graphHelper: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, graphHelper: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._gantt = gantt;\n\t}\n\tisCircularLink = (link: ILink): boolean => {\n\t\treturn !!this.getLoopContainingLink(link);\n\t}\n\n\tgetLoopContainingLink = (link: ILink): any => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\t\tconst gantt = this._gantt;\n\n\t\tlet allRelations = linksBuilder.getLinkedTasks();\n\t\tif (!gantt.isLinkExists(link.id)) {\n\t\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t\t}\n\n\t\tconst cycles = graphHelper.findLoops(allRelations);\n\n\t\tconst found = false;\n\t\tfor (let i = 0; i < cycles.length && !found; i++) {\n\t\t\tconst links = cycles[i].links;\n\t\t\tfor (let j = 0; j < links.length; j++) {\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif (links[j] == link.id) {\n\t\t\t\t\treturn cycles[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindCycles = () => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\n\t\tconst allRelations = linksBuilder.getLinkedTasks();\n\t\treturn graphHelper.findLoops(allRelations);\n\t}\n}\n","var helpers = require(\"../../utils/helpers\");\n\nmodule.exports = function(){\n\treturn {\n\t\tgetVertices: function(relations){\n\t\t\tvar ids = {};\n\t\t\tvar rel;\n\t\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\t\trel = relations[i];\n\t\t\t\tids[rel.target] = rel.target;\n\t\t\t\tids[rel.source] = rel.source;\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\t\t\tvar id;\n\t\t\tfor(var i in ids){\n\t\t\t\tid = ids[i];\n\t\t\t\tvertices.push(id);\n\t\t\t}\n\n\t\t\treturn vertices;\n\t\t},\n\t\ttopologicalSort: function(edges){\n\t\t\tvar vertices = this.getVertices(edges);\n\t\t\tvar hash = {};\n\n\t\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tvar successor = hash[edges[i].target];\n\t\t\t\tsuccessor.$target.push(i);\n\t\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t\t}\n\n\t\t\t// topological sort, Kahn's algorithm\n\t\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\t\tvar L = [];\n\n\t\t\twhile(S.length){\n\t\t\t\tvar n = S.pop();\n\n\t\t\t\tL.push(n);\n\n\t\t\t\tvar node = hash[n];\n\n\t\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\t\tm.$incoming--;\n\t\t\t\t\tif(!m.$incoming){\n\t\t\t\t\t\tS.push(m.id);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn L;\n\n\t\t},\n\t\tgroupAdjacentEdges: function(edges){\n\t\t\tvar res = {};\n\t\t\tvar edge;\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tedge = edges[i];\n\t\t\t\tif(!res[edge.source]){\n\t\t\t\t\tres[edge.source] = [];\n\t\t\t\t}\n\t\t\t\tres[edge.source].push(edge);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\t\t// iterative implementation\n\t\t\tvar verticesHash = {};\n\t\t\tvar stack = [];\n\t\t\tvar edgesFromTasks = this.groupAdjacentEdges(edges);\n\t\t\tvar recurse = false;\n\t\t\tvar connectedComponents = [];\n\n\t\t\tfor(var i = 0; i < vertices.length; i++){\n\t\t\t\tvar root = getVertex(vertices[i]);\n\t\t\t\tif(root.visited) continue;\n\t\t\t\tvar workStack = [root];\n\t\t\t\tvar index = 0;\n\t\t\t\twhile(workStack.length){\n\t\t\t\t\tvar v = workStack.pop();\n\n\t\t\t\t\tif(!v.visited){\n\t\t\t\t\t\tv.index = index;\n\t\t\t\t\t\tv.lowLink = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tstack.push(v);\n\t\t\t\t\t\tv.onStack = true;\n\t\t\t\t\t\tv.visited = true;\n\t\t\t\t\t}\n\t\t\t\t\trecurse = false;\n\t\t\t\t\tvar edges = edgesFromTasks[v.id] || [];\n\t\t\t\t\tfor(var e = 0; e < edges.length; e++){\n\t\t\t\t\t\tvar w = getVertex(edges[e].target);\n\t\t\t\t\t\tw.edge = edges[e];\n\t\t\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t\t\tworkStack.push(v);\n\t\t\t\t\t\t\tworkStack.push(w);\n\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(recurse)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (v.index == v.lowLink){\n\t\t\t\t\t\tvar com = {tasks:[], links:[]};\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tw = stack.pop();\n\t\t\t\t\t\t\tw.onStack = false;\n\t\t\t\t\t\t\tcom.tasks.push(w.id);\n\t\t\t\t\t\t\tif(w.edge){\n\t\t\t\t\t\t\t\tcom.links.push(w.edge.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w == v){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconnectedComponents.push(com);\n\t\t\t\t\t}\n\t\t\t\t\tif(workStack.length){\n\t\t\t\t\t\tw = v;\n\t\t\t\t\t\tv = workStack[workStack.length - 1];\n\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn connectedComponents;\n\n\t\t\tfunction getVertex(id){\n\t\t\t\tif(!verticesHash[id]){\n\t\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined, edge: undefined};\n\t\t\t\t}\n\n\t\t\t\treturn verticesHash[id];\n\t\t\t}\n\t\t},\n\n\t\tfindLoops: function(relations){\n\t\t\tvar cycles = [];\n\n\t\t\thelpers.forEach(relations, function(rel){\n\t\t\t\tif(rel.target == rel.source)\n\t\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t\t});\n\n\t\t\tvar vertices = this.getVertices(relations);\n\n\t\t\tvar connectedComponents = this.tarjanStronglyConnectedComponents(vertices, relations);\n\t\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\t\tif(component.tasks.length > 1){\n\t\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn cycles;\n\t\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t\t}\n\t};\n};","interface IFlagHash {\n\t[id: string]: boolean;\n}\n\nfunction findGroups(links: IInternalLink[]): IConnectedGroup[] {\n\tconst visited: IFlagHash = {};\n\tconst groups = [];\n\tlet source: TaskID;\n\tlet target: TaskID;\n\tlet root: TaskID;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (let i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tconst length = links.length;\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t\tif (length !== links.length) {\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(\n\tv: TaskID,\n\tlinks: IInternalLink[],\n\tvisited: IFlagHash\n): IConnectedGroupsDetailed {\n\tconst queue: TaskID[] = [v];\n\tconst groupTasks: TaskID[] = [];\n\tconst groupLinksInternal: { [hashSum: string]: IInternalLink } = {};\n\tconst groupLinksPublic: { [id: string]: boolean } = {};\n\n\tlet currentVertex: TaskID;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\t\tconst link = links[i];\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif ((link.source == currentVertex || link.sourceParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.target]) {\n\t\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t} else if ((link.target == currentVertex || link.targetParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.source]) {\n\t\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst linksArray: LinkID[] = [];\n\tconst linksObjects: IInternalLink[] = [];\n\tfor (const i in groupLinksPublic) {\n\t\tlinksArray.push(i);\n\t}\n\tfor (const i in groupLinksInternal) {\n\t\tlinksObjects.push(groupLinksInternal[i]);\n\t}\n\t// return everything in the current \"group\"\n\treturn { tasks: groupTasks, links: linksArray, processedLinks: linksObjects };\n}\n\nexport class ConnectedGroupsHelper {\n\tprivate _linksBuilder: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._gantt = gantt;\n\t}\n\n\tgetConnectedGroupRelations = (id: TaskID): IInternalLink[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tconst group = breadthFirstSearch(id, links, {});\n\t\treturn group.processedLinks;\n\t}\n\n\tgetConnectedGroup = (id: TaskID): IConnectedGroup | IConnectedGroup[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tif (id !== undefined) {\n\t\t\tif (this._gantt.getTask(id).type === this._gantt.config.types.project) {\n\t\t\t\treturn { tasks: [], links: [] };\n\t\t\t}\n\n\t\t\tconst group = breadthFirstSearch(id, links, {});\n\t\t\treturn {\n\t\t\t\ttasks: group.tasks,\n\t\t\t\tlinks: group.links\n\t\t\t};\n\t\t} else {\n\t\t\treturn findGroups(links).map(group => ({ tasks: group.tasks, links: group.links }));\n\t\t}\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AsapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AsapStrategy {\n\t\tconst instance = new AsapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\tresolveRelationDate(\n\t\ttaskId: TaskID,\n\t\tadjacentLinks: ITaskRelations,\n\t\tplansHash: IPlansHash\n\t): TaskPlan {\n\t\tlet minStart = null;\n\t\tlet linkId = null;\n\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.predecessors;\n\n\t\tlet minRelationDate = null;\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tconst constraintDate = this.getEarliestStartDate(\n\t\t\t\trelation,\n\t\t\t\tplansHash,\n\t\t\t\ttask\n\t\t\t);\n\n\t\t\tif (this.isSmallerOrDefault(minRelationDate, constraintDate, task)) {\n\t\t\t\tminRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.isSmallerOrDefault(defaultStart, constraintDate, task) &&\n\t\t\t\tthis.isSmallerOrDefault(minStart, constraintDate, task)\n\t\t\t) {\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_start) {\n\t\t\tif (this.isSmallerOrDefault(task.start_date, this._gantt.config.project_start, task)) {\n\t\t\t\tminStart = this._gantt.config.project_start;\n\t\t\t}\n\t\t}\n\n\t\tlet maxEnd = null;\n\t\tif (minStart) {\n\t\t\tminStart = this._gantt.getClosestWorkTime({\n\t\t\t\tdate: minStart,\n\t\t\t\tdir: \"future\",\n\t\t\t\ttask\n\t\t\t});\n\t\t\tmaxEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minStart,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\tconst masterPlan = plansHash[taskId];\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.start_date = minStart;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.kind = \"asap\";\n\n\t\tif (minRelationDate) {\n\t\t\tcurrentPlan.earliestSchedulingStart = minRelationDate;\n\t\t\tcurrentPlan.earliestSchedulingEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minRelationDate,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn currentPlan;\n\t}\n\n\tprotected isEqual(dateA: Date, dateB: Date, task: ITask): boolean {\n\t\treturn !this._gantt._hasDuration(dateA, dateB, task);\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && !this.isEqual(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isSmallerOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t}\n\n\tprotected getPredecessorEndDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.end_date;\n\t\t} else if (plan.end_date) {\n\t\t\tres = plan.end_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: plan.start_date,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getEarliestStartDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask): Date {\n\t\tconst predecessorEnd = this.getPredecessorEndDate(\n\t\t\trelation.source,\n\t\t\tplansHash\n\t\t);\n\t\tconst successor = task;\n\n\t\tlet successorStart = this._gantt.getClosestWorkTime({\n\t\t\tdate: predecessorEnd,\n\t\t\tdir: \"future\",\n\t\t\ttask: successor\n\t\t});\n\n\t\tif (\n\t\t\tpredecessorEnd &&\n\t\t\trelation.lag &&\n\t\t\trelation.lag * 1 === relation.lag * 1\n\t\t) {\n\t\t\tsuccessorStart = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: predecessorEnd,\n\t\t\t\tduration: relation.lag * 1,\n\t\t\t\ttask: successor\n\t\t\t});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AlapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AlapStrategy {\n\t\tconst instance = new AlapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\n\tresolveRelationDate(taskId: TaskID, adjacentLinks: ITaskRelations, plansHash: IPlansHash): TaskPlan {\n\t\tlet maxEnd = null;\n\t\tlet linkId = null;\n\t\tlet maxStart = null;\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.successors;\n\t\tlet maxRelationDate = null;\n\t\tconst masterPlan = plansHash[taskId];\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\tconst constraintDate = this.getLatestEndDate(relation, plansHash, task);\n\t\t\tconst constraintStartDate = this._gantt.calculateEndDate({ start_date: constraintDate, duration: - task.duration, task });\n\n\t\t\tif (this.isGreaterOrDefault(maxRelationDate, constraintDate, task)) {\n\t\t\t\tmaxRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (this.isGreaterOrDefault(defaultStart, constraintStartDate, task) && this.isGreaterOrDefault(maxEnd, constraintDate, task)) {\n\t\t\t\tmaxEnd = constraintDate;\n\t\t\t\tmaxStart = constraintStartDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_end) {\n\t\t\tif (this.isGreaterOrDefault(this._gantt.config.project_end, task.end_date, task)) {\n\t\t\t\tmaxEnd = this._gantt.config.project_end;\n\t\t\t}\n\t\t}\n\n\t\tif (maxEnd) {\n\n\t\t\tmaxEnd = this._gantt.getClosestWorkTime({ date: maxEnd, dir: \"future\", task });\n\t\t\tmaxStart = this._gantt.calculateEndDate({ start_date: maxEnd, duration: - task.duration, task });\n\t\t}\n\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.start_date = maxStart;\n\t\tcurrentPlan.kind = \"alap\";\n\n\t\tif (maxRelationDate) {\n\t\t\tcurrentPlan.latestSchedulingStart = this._gantt.calculateEndDate({ start_date: maxRelationDate, duration: - task.duration, task });\n\t\t\tcurrentPlan.latestSchedulingEnd = maxRelationDate;\n\t\t}\n\n\t\treturn currentPlan;\n\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && this._gantt._hasDuration(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isGreaterOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(bigDate, smallDate, task));\n\t}\n\n\tprotected getSuccessorStartDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.start_date;\n\t\t} else if (plan.start_date) {\n\t\t\tres = plan.start_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({ start_date: plan.end_date, duration: - task.duration, task });\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getLatestEndDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask) {\n\t\tconst successorStart = this.getSuccessorStartDate(relation.target, plansHash);\n\t\tconst predecessor = task;\n\n\t\tlet predecessorEnd = this._gantt.getClosestWorkTime({ date: successorStart, dir: \"past\", task: predecessor });\n\n\t\tif (predecessorEnd && relation.lag && relation.lag * 1 === relation.lag * 1) {\n\t\t\tpredecessorEnd = this._gantt.calculateEndDate({ start_date: predecessorEnd, duration: -relation.lag * 1, task: predecessor });\n\t\t}\n\n\t\treturn predecessorEnd;\n\t}\n}","import { AlapStrategy } from \"./alap_strategy\";\nimport { AsapStrategy } from \"./asap_strategy\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { ConstraintsHelper } from \"./constraints\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class AutoSchedulingPlanner {\n\tprivate _gantt: any;\n\tprivate _constraintsHelper: ConstraintsHelper;\n\tprivate _graphHelper: any;\n\tprivate _asapStrategy: AsapStrategy;\n\tprivate _alapStrategy: AlapStrategy;\n\n\tconstructor(\n\t\tgantt: any,\n\t\tgraphHelper: any,\n\t\tconstraintsHelper: ConstraintsHelper\n\t) {\n\t\tthis._gantt = gantt;\n\t\tthis._constraintsHelper = constraintsHelper;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._asapStrategy = AsapStrategy.Create(gantt);\n\t\tthis._alapStrategy = AlapStrategy.Create(gantt);\n\t}\n\n\tgeneratePlan(relations: IInternalLink[], constraints: ITask[]): TaskPlan[] {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst gantt = this._gantt;\n\t\tconst constraintsHelper = this._constraintsHelper;\n\t\tconst alapStrategy = this._alapStrategy;\n\t\tconst asapStrategy = this._asapStrategy;\n\n\t\tconst {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash } = this.buildWorkCollections(relations, constraints, graphHelper);\n\n\t\tlet result: TaskPlan[];\n\n\t\tthis.processConstraints(orderedIds, plansHash, gantt, constraintsHelper);\n\n\t\tif (gantt.config.schedule_from_end) {\n\t\t\t// when scheduling from end - iterate tasks from end and schedule them as late as possible\n\t\t\t// after that - iterate tasks from start and schedule asap tasks\n\t\t\tresult = this.iterateTasks(reversedIds, orderedIds, constraintsHelper.isAlapTask, alapStrategy, asapStrategy, relationsMap, plansHash);\n\t\t} else {\n\t\t\t// when scheduling from end - iterate tasks from start and schedule them as soon as possible\n\t\t\t// after that - iterate tasks from end and schedule asap alap\n\t\t\tresult = this.iterateTasks(orderedIds, reversedIds, constraintsHelper.isAsapTask, asapStrategy, alapStrategy, relationsMap, plansHash);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyProjectPlan(projectPlan: TaskPlan[]): ITask[] {\n\t\tconst gantt = this._gantt;\n\n\t\tlet plan: TaskPlan;\n\t\tlet task: ITask;\n\t\tlet link: ILink;\n\t\tlet reason: ITask;\n\n\t\tconst updateTasks = [];\n\t\tfor (let i = 0; i < projectPlan.length; i++) {\n\t\t\tlink = null;\n\t\t\treason = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif (!plan.task) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif (plan.link) {\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newDate = null;\n\t\t\tif (\n\t\t\t\tplan.start_date &&\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf()\n\t\t\t) {\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif (!newDate) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [\n\t\t\t\ttask,\n\t\t\t\tnewDate,\n\t\t\t\tlink,\n\t\t\t\treason\n\t\t\t]);\n\t\t}\n\t\treturn updateTasks;\n\t}\n\n\tprotected iterateTasks(\n\t\tmainSequence: TaskID[],\n\t\tsecondarySequence: TaskID[],\n\t\tisMainSequence: (task: ITask) => boolean,\n\t\tmainSequenceStrategy: ISchedulingStrategy,\n\t\tsecondarySequenceStrategy: ISchedulingStrategy,\n\t\trelationsMap: ITaskLinksMap,\n\t\tplansHash: IPlansHash\n\n\t): TaskPlan[] {\n\t\tconst gantt = this._gantt;\n\t\tconst result: TaskPlan[] = [];\n\n\t\tfor (let i = 0; i < mainSequence.length; i++) {\n\t\t\tconst currentId = mainSequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\t\t\tconst plan = mainSequenceStrategy.resolveRelationDate(\n\t\t\t\tcurrentId,\n\t\t\t\trelationsMap[currentId],\n\t\t\t\tplansHash\n\t\t\t);\n\t\t\tthis.limitPlanDates(task, plan);\n\t\t\tif (isMainSequence(task)) {\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t} else {\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondarySequence.length; i++) {\n\t\t\tconst currentId = secondarySequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tif (!isMainSequence(task)) {\n\t\t\t\tconst plan = secondarySequenceStrategy.resolveRelationDate(\n\t\t\t\t\tcurrentId,\n\t\t\t\t\trelationsMap[currentId],\n\t\t\t\t\tplansHash\n\t\t\t\t);\n\t\t\t\tthis.limitPlanDates(task, plan);\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected processResolvedDate(\n\t\ttask: ITask,\n\t\tplan: TaskPlan,\n\t\tresult: TaskPlan[],\n\t\tplansHash: any\n\t): void {\n\t\tif (plan.start_date && this._gantt.isLinkExists(plan.link)) {\n\t\t\tlet link = null;\n\t\t\tlet reason = null;\n\t\t\tif (plan.link) {\n\t\t\t\tlink = this._gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf() &&\n\t\t\t\tthis._gantt.callEvent(\"onBeforeTaskAutoSchedule\", [\n\t\t\t\t\ttask,\n\t\t\t\t\tplan.start_date,\n\t\t\t\t\tlink,\n\t\t\t\t\treason\n\t\t\t\t]) === false\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tplansHash[task.id] = plan;\n\t\tif (plan.start_date) {\n\t\t\tresult.push(plan);\n\t\t}\n\t}\n\n\tprotected limitPlanDates(task: ITask, plan: TaskPlan): TaskPlan {\n\t\tconst effectiveStart = plan.start_date || task.start_date;\n\n\t\tif (plan.earliestStart) {\n\t\t\tif (effectiveStart < plan.earliestStart) {\n\t\t\t\tplan.start_date = plan.earliestStart;\n\t\t\t\tplan.end_date = plan.earliestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestStart) {\n\t\t\tif (effectiveStart > plan.latestStart) {\n\t\t\t\tplan.start_date = plan.latestStart;\n\t\t\t\tplan.end_date = plan.latestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestSchedulingStart && effectiveStart > plan.latestSchedulingStart) {\n\t\t\tplan.start_date = plan.latestSchedulingStart;\n\t\t\tplan.end_date = plan.latestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.earliestSchedulingStart && effectiveStart < plan.earliestSchedulingStart) {\n\t\t\tplan.start_date = plan.earliestSchedulingStart;\n\t\t\tplan.end_date = plan.earliestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.start_date) { // start/end dates are either both defined or both not\n\t\t\tif (plan.start_date > plan.latestSchedulingStart ||\n\t\t\t\tplan.start_date < plan.earliestSchedulingStart ||\n\t\t\t\tplan.start_date > plan.latestStart ||\n\t\t\t\tplan.start_date < plan.earliestStart ||\n\t\t\t\tplan.end_date > plan.latestSchedulingEnd ||\n\t\t\t\tplan.end_date < plan.earliestSchedulingEnd ||\n\t\t\t\tplan.end_date > plan.latestEnd ||\n\t\t\t\tplan.end_date < plan.earliestEnd) {\n\n\t\t\t\tplan.conflict = true;\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tprotected buildWorkCollections(relations: IInternalLink[], constraints: ITask[], graphHelper: any) {\n\t\tconst gantt = this._gantt;\n\t\tconst orderedIds: TaskID[] = graphHelper.topologicalSort(relations);\n\t\tconst reversedIds: TaskID[] = orderedIds.slice().reverse();\n\t\tconst plansHash: IPlansHash = {};\n\n\t\tconst relationsMap: ITaskLinksMap = {};\n\t\tfor (let i = 0, len = orderedIds.length; i < len; i++) {\n\t\t\tconst id = orderedIds[i];\n\t\t\tconst task = gantt.getTask(id);\n\t\t\tif (task.auto_scheduling === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelationsMap[id] = {\n\t\t\t\tsuccessors: [],\n\t\t\t\tpredecessors: []\n\t\t\t};\n\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfor (let i = 0, len = constraints.length; i < len; i++) {\n\t\t\tconst task = constraints[i];\n\n\t\t\tif (plansHash[task.id] === undefined) {\n\t\t\t\treversedIds.unshift(task.id);\n\t\t\t\torderedIds.unshift(task.id);\n\t\t\t\tplansHash[task.id] = null;\n\t\t\t\trelationsMap[task.id] = {\n\t\t\t\t\tsuccessors: [],\n\t\t\t\t\tpredecessors: []\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = relations.length; i < len; i++) {\n\t\t\tconst rel = relations[i];\n\t\t\tif (relationsMap[rel.source]) {\n\t\t\t\trelationsMap[rel.source].successors.push(rel);\n\t\t\t}\n\n\t\t\tif (relationsMap[rel.target]) {\n\t\t\t\trelationsMap[rel.target].predecessors.push(rel);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash\n\t\t};\n\t}\n\n\tprotected processConstraints(orderedIds: TaskID[], plansHash: IPlansHash, gantt: any, constraintsHelper: ConstraintsHelper) {\n\t\tfor (let i = 0; i < orderedIds.length; i++) {\n\t\t\tconst currentId = orderedIds[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tconst constraintType = constraintsHelper.getConstraintType(task);\n\t\t\tif (\n\t\t\t\tconstraintType &&\n\t\t\t\tconstraintType !== ConstraintTypes.ASAP &&\n\t\t\t\tconstraintType !== ConstraintTypes.ALAP\n\t\t\t) {\n\t\t\t\tconst plan = constraintsHelper.processConstraint(\n\t\t\t\t\ttask,\n\t\t\t\t\tTaskPlan.Create()\n\t\t\t\t);\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { ConstraintTypes } from \"./constraint_types\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class ConstraintsHelper {\n\tstatic Create(gantt: any): ConstraintsHelper {\n\t\treturn new ConstraintsHelper(gantt);\n\t}\n\n\tprivate _gantt: any;\n\tprivate constructor(gantt: any) {\n\t\tthis._gantt = gantt;\n\t}\n\n\tisAsapTask = (task: ITask): boolean => {\n\t\tconst constraintType = this.getConstraintType(task);\n\t\tif (this._gantt.config.schedule_from_end) {\n\t\t\tif (constraintType === ConstraintTypes.ASAP) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (constraintType === ConstraintTypes.ALAP) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tisAlapTask = (task: ITask): boolean => {\n\t\treturn !this.isAsapTask(task);\n\t}\n\n\tgetConstraintType = (task: ITask): ConstraintTypes => {\n\t\t// in case of backward scheduling, tasks without explicit constraints are considered ALAP tasks\n\t\tif (task.constraint_type) {\n\t\t\treturn task.constraint_type;\n\t\t} else if (this._gantt.config.schedule_from_end) {\n\t\t\treturn ConstraintTypes.ALAP;\n\t\t} else {\n\t\t\treturn ConstraintTypes.ASAP;\n\t\t}\n\t}\n\n\thasConstraint = (task: ITask): boolean => {\n\t\treturn !!this.getConstraintType(task);\n\t}\n\n\tprocessConstraint = (task: ITask, plan: TaskPlan): TaskPlan => {\n\t\tif (this.hasConstraint(task)) {\n\t\t\tif (\n\t\t\t\ttask.constraint_type === ConstraintTypes.ALAP ||\n\t\t\t\ttask.constraint_type === ConstraintTypes.ASAP\n\t\t\t) {\n\t\t\t\t// this kind of constraint is calculated after main scheduling\n\t\t\t} else {\n\t\t\t\tconst constraintDate = task.constraint_date;\n\n\t\t\t\tconst newPlan = TaskPlan.Create(plan);\n\t\t\t\tnewPlan.task = task.id;\n\n\t\t\t\tswitch (task.constraint_type) {\n\t\t\t\t\tcase ConstraintTypes.SNET:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.SNLT:\n\t\t\t\t\t\tnewPlan.latestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.latestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.latestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNET:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNLT:\n\t\t\t\t\t\tnewPlan.latestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MSO:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MFO:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn newPlan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan;\n\t}\n\n\tgetConstraints = (id: TaskID, relations: IInternalLink[]): ITask[] => {\n\t\tconst result = [];\n\t\tconst tasks = {};\n\n\t\tconst store = (task: any) => {\n\t\t\tif (tasks[task.id]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasConstraint(task) && !this._gantt.isSummaryTask(task)) {\n\t\t\t\ttasks[task.id] = task;\n\t\t\t}\n\t\t};\n\n\t\tif (this._gantt.isTaskExists(id)) {\n\t\t\tconst task = this._gantt.getTask(id);\n\t\t\tstore(task);\n\t\t}\n\n\t\tthis._gantt.eachTask(task => store(task), id);\n\n\t\tlet current;\n\t\tif (relations) {\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst rel = relations[i];\n\t\t\t\tif (!tasks[rel.target]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.target);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t\tif (!tasks[rel.source]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.source);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const taskId in tasks) {\n\t\t\tresult.push(tasks[taskId]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","require(\"../core/relations/links_common\")(gantt);\n\nvar linksBuilder = require(\"../core/relations/links_builder\")(gantt);\nvar graphHelper = require(\"../core/relations/graph_helper\")(gantt);\nvar ConstraintTypes = require(\"./auto_scheduling/constraint_types\").ConstraintTypes;\n\nvar constraintsHelper = require(\"./auto_scheduling/constraints\").ConstraintsHelper.Create(\n\tgantt\n);\nvar AutoSchedulingPlanner = require(\"./auto_scheduling/planner\")\n\t.AutoSchedulingPlanner;\n\nvar planner = new AutoSchedulingPlanner(gantt, graphHelper, constraintsHelper);\n\nvar ConnectedGroupsHelper = require(\"./auto_scheduling/connected_groups\")\n\t.ConnectedGroupsHelper;\nvar connectedGroups = new ConnectedGroupsHelper(gantt, linksBuilder);\n\nvar LoopsFinder = require(\"./auto_scheduling/loops_finder\").LoopsFinder;\n\nvar loopsFinder = new LoopsFinder(\n\tgantt,\n\tgraphHelper,\n\tlinksBuilder\n);\n\ngantt.getConnectedGroup = connectedGroups.getConnectedGroup;\ngantt.getConstraintType = constraintsHelper.getConstraintType;\ngantt.getConstraintLimitations = function (task) {\n\tvar plan = constraintsHelper.processConstraint(task, null);\n\treturn {\n\t\tearliestStart: plan.earliestStart || null,\n\t\tearliestEnd: plan.earliestEnd || null,\n\t\tlatestStart: plan.latestStart || null,\n\t\tlatestEnd: plan.latestEnd || null\n\t};\n};\n\ngantt.isCircularLink = loopsFinder.isCircularLink;\ngantt.findCycles = loopsFinder.findCycles;\n\ngantt.config.constraint_types = ConstraintTypes;\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\ngantt.config.project_start = null;\ngantt.config.project_end = null;\ngantt.config.schedule_from_end = false;\n\nfunction preferInitialTaskDates(startTask, relations) {\n\t// TODO: remove in 7.0\n\tif (!gantt.config.auto_scheduling_compatibility) {\n\t\treturn;\n\t}\n\n\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t// will be removed in future versions\n\tfor (var i = 0; i < relations.length; i++) {\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif (!gantt.config.auto_scheduling_strict || rel.target == startTask) {\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n}\n\nfunction updateParentsAndCallEvents(updatedTasks) {\n\tfunction resetTime(task) {\n\t\tif (batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif (task.start_date.valueOf() != start || task.end_date.valueOf() != end) {\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor (var i = 0; !batchUpdate && i < children.length; i++) {\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif (updatedTasks.length == 1) {\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t} else if (updatedTasks.length) {\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload() {\n\t\tfor (var i = 0; i < updatedTasks.length; i++) {\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif (batchUpdate) {\n\t\tgantt.batchUpdate(payload);\n\t} else {\n\t\tpayload();\n\t}\n}\n\ngantt._autoSchedule = function (id, relations) {\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar constraints = constraintsHelper.getConstraints(\n\t\tid,\n\t\tgantt.isTaskExists(id) ? relations : null\n\t);\n\n\tvar updatedTasks = [];\n\n\tvar cycles = graphHelper.findLoops(relations);\n\tif (cycles.length) {\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t} else {\n\t\tpreferInitialTaskDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations, constraints);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tupdateParentsAndCallEvents(updatedTasks);\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n};\n\ngantt.autoSchedule = function (id, inclusive) {\n\tif (inclusive === undefined) {\n\t\tinclusive = true;\n\t} else {\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations;\n\tif (id !== undefined) {\n\t\tif (gantt.config.auto_scheduling_compatible) {\n\t\t\tlinksBuilder.getLinkedTasks(id, inclusive);\n\t\t} else {\n\t\t\trelations = connectedGroups.getConnectedGroupRelations(id);\n\t\t}\n\t} else {\n\t\trelations = linksBuilder.getLinkedTasks();\n\t}\n\n\tgantt._autoSchedule(id, relations);\n};\n\ngantt.attachEvent(\"onTaskLoading\", function (task) {\n\tif (task.constraint_date && typeof task.constraint_date === \"string\") {\n\t\ttask.constraint_date = gantt.date.parseDate(task.constraint_date, \"parse_date\");\n\t}\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\ngantt.attachEvent(\"onTaskCreated\", function (task) {\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\n\nvar attachUIHandlers = require(\"./auto_scheduling/ui_handlers\").attachUIHandlers;\nattachUIHandlers(gantt, linksBuilder, loopsFinder, connectedGroups);\n","module.exports = function (gantt) {\n\t// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function () {\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif (caching && formattedLinksStash[link.id]) {\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif (caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\n\tgantt._isAutoSchedulable = function (task) {\n\t\treturn task.auto_scheduling !== false;\n\t};\n\n\tgantt._getImplicitLinks = function (link, parent, selectOffset, selectSourceLinks) {\n\t\tvar relations = [];\n\n\t\tif (this.isSummaryTask(parent)) {\n\n\t\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t\t// it will be enough to check the first/last tasks of the chain\n\t\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\t\tvar children = {};\n\t\t\tthis.eachTask(function (c) {\n\t\t\t\tif (!this.isSummaryTask(c)) {\n\t\t\t\t\tchildren[c.id] = c;\n\t\t\t\t}\n\t\t\t}, parent.id);\n\n\t\t\tvar skipChild;\n\n\t\t\tfor (var c in children) {\n\t\t\t\tvar task = children[c];\n\t\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\t\tskipChild = false;\n\n\t\t\t\tfor (var l = 0; l < linksCollection.length; l++) {\n\t\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\t\tif (siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false) {\n\t\t\t\t\t\tif ((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration)) {\n\t\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skipChild) {\n\t\t\t\t\trelations.push({ task: task.id, taskParent: task.parent, lag: selectOffset(task) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\trelations.push({ task: parent.id, taskParent: parent.parent, lag: 0 });\n\t\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\t\tfor (var i = 0; i < linksIds.length; i++) {\n\t\t\tvar link = this.getLink(linksIds[i]);\n\t\t\tif (this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\t\tvar target = this.getTask(link.target);\n\t\t\t\tif (this._isAutoSchedulable(target)) {\n\t\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\t\tvar stop = false;\n\t\tvar inheritedRelations = [];\n\t\tvar cacheCollection;\n\t\tif (this.isTaskExists(task.id)) {\n\t\t\tthis.eachParent(function (parent) {\n\t\t\t\tif (stop)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (caching) {\n\t\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\t\tif (cacheCollection[parent.id]) {\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(cacheCollection[parent.id]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar parentDependencies;\n\t\t\t\tif (this.isSummaryTask(parent)) {\n\t\t\t\t\tif (!this._isAutoSchedulable(parent)) {\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\t\tif (caching) {\n\t\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(parentDependencies);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}, task.id, this);\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif (skipInherited) {\n\t\t\treturn successors;\n\t\t} else {\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = task.id + skipInherited;\n\t\tvar result;\n\n\t\tif (caching && getPredecessorsCache[key]) {\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif (skipInherited) {\n\t\t\tresult = predecessors;\n\t\t} else {\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif (caching) {\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent,\n\t\t\thashSum: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\tres.hashSum = res.lag + \"_\" + res.link + \"_\" + res.source + \"_\" + res.target;\n\t\treturn res;\n\t};\n};"],"sourceRoot":""}